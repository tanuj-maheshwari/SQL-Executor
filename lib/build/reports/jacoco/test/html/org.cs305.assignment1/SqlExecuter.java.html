<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlExecuter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lib</a> &gt; <a href="index.source.html" class="el_package">org.cs305.assignment1</a> &gt; <span class="el_source">SqlExecuter.java</span></div><h1>SqlExecuter.java</h1><pre class="source lang-java linenums">package org.cs305.assignment1;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

import org.w3c.dom.*;

import javax.xml.parsers.*;
import java.io.*;
import java.sql.*;

import org.cs305.assignment1.interfaces.QueryPopulator;
import org.cs305.assignment1.interfaces.SqlRunner;
import org.cs305.assignment1.interfaces.XmlParser;

public class SqlExecuter implements SqlRunner, XmlParser, QueryPopulator {
    
    private final String pathToXMLFile;
    private final Connection dbConnection;

    /**
     * Default consructor
     * @param pathToXMLFile Absolute path to the XML file
     * @param dbConnection Database connection object (of type java.sql.Connection.class)
     */
<span class="fc" id="L30">    public SqlExecuter(String pathToXMLFile, Connection dbConnection) {</span>
<span class="fc" id="L31">        this.pathToXMLFile = pathToXMLFile;</span>
<span class="fc" id="L32">        this.dbConnection = dbConnection;</span>
<span class="fc" id="L33">    }</span>

    /**
    * Checks if a class is a wrapper for primitive types
    * @param clazz Class of object
    * @return true if class is a wrapper
    */
    private static boolean isWrapperType(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">        return clazz.equals(Boolean.class) || </span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">            clazz.equals(Integer.class) ||</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">            clazz.equals(Character.class) ||</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">            clazz.equals(Byte.class) ||</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">            clazz.equals(Short.class) ||</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">            clazz.equals(Double.class) ||</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            clazz.equals(Long.class) ||</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">            clazz.equals(Float.class);</span>
    }

    /**
    * Parses the XML file to get the raw query.
    * @param queryId the id of the required query
    * @param queryParam Parameter(s) to be used in the query.
    * @return The raw SQL query
     * @throws Exception
    */
    public &lt;P&gt; String getRawQueryFromXML(String queryId, P queryParam) {
        //get XML file as a document
        try{
<span class="fc" id="L61">            File xmlFile = new File(pathToXMLFile);</span>
<span class="fc" id="L62">            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L63">            DocumentBuilder dbBuilder = dbFactory.newDocumentBuilder();</span>
<span class="fc" id="L64">            Document doc = dbBuilder.parse(xmlFile);</span>
<span class="fc" id="L65">            doc.getDocumentElement().normalize();</span>
            //get the Query with queryID
<span class="fc" id="L67">            String rawQuery = &quot;&quot;;</span>
<span class="fc" id="L68">            NodeList nList = doc.getElementsByTagName(&quot;sql&quot;);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            for(int i=0; i&lt;nList.getLength(); i++) {</span>
<span class="fc" id="L70">                Element sqlElement = (Element) nList.item(i);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">                if(queryId.equals(sqlElement.getAttribute(&quot;id&quot;))) {</span>
                    //paramType in XML should match with object type passed
                    //if queryParam is null, paramType must also be null
<span class="fc bfc" id="L74" title="All 2 branches covered.">                    if(queryParam == null) {</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">                        if (sqlElement.getAttribute(&quot;paramType&quot;).equals(&quot;null&quot;)) {</span>
<span class="fc" id="L76">                            rawQuery = sqlElement.getTextContent().trim();</span>
<span class="fc" id="L77">                            break;</span>
                        }
                        else {
<span class="fc" id="L80">                            throw new RuntimeException(&quot;Null argument&quot;);</span>
                        }
                    }
                    //if queryParam is not null, the classes must match
<span class="fc bfc" id="L84" title="All 2 branches covered.">                    else if(sqlElement.getAttribute(&quot;paramType&quot;).equals(queryParam.getClass().getName())) {</span>
<span class="fc" id="L85">                        rawQuery = sqlElement.getTextContent().trim();</span>
<span class="fc" id="L86">                        break;</span>
                    } else {
<span class="fc" id="L88">                        throw new RuntimeException(&quot;Parameter object type mismatch, classes &quot; + sqlElement.getAttribute(&quot;paramType&quot;) + &quot; and &quot; + queryParam.getClass().getName());</span>
                    }
                }
            }
            //query shouldn't be empty
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if(rawQuery.equals(&quot;&quot;)) {</span>
<span class="fc" id="L94">                throw new RuntimeException(&quot;No query with id = &quot; + queryId + &quot; found&quot;);</span>
            }
<span class="fc" id="L96">            return rawQuery;</span>
<span class="fc" id="L97">        } catch(Exception e) {</span>
<span class="fc" id="L98">        throw new RuntimeException(e);</span>
        }
    }

    /**
    * Converts an object of primitive type array to an object array
    * @param queryParam Primitive type array
    * @return object array
    */
    private static &lt;P&gt; Object[] getObjectArrayFromPrimitiveArrayObject(P queryParam) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if(queryParam.getClass().getComponentType() == int.class) {</span>
<span class="fc" id="L109">            int[] queryParamArray = (int[]) queryParam;</span>
<span class="fc" id="L110">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L112">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L114">            return objectArray;</span>
        }
<span class="fc bfc" id="L116" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == byte.class) {</span>
<span class="fc" id="L117">            byte[] queryParamArray = (byte[]) queryParam;</span>
<span class="fc" id="L118">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L120">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L122">            return objectArray;</span>
        }
<span class="fc bfc" id="L124" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == short.class) {</span>
<span class="fc" id="L125">            short[] queryParamArray = (short[]) queryParam;</span>
<span class="fc" id="L126">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L128">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L130">            return objectArray;</span>
        }
<span class="fc bfc" id="L132" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == long.class) {</span>
<span class="fc" id="L133">            long[] queryParamArray = (long[]) queryParam;</span>
<span class="fc" id="L134">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L136">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L138">            return objectArray;</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == float.class) {</span>
<span class="fc" id="L141">            float[] queryParamArray = (float[]) queryParam;</span>
<span class="fc" id="L142">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L144">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L146">            return objectArray;</span>
        }
<span class="fc bfc" id="L148" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == double.class) {</span>
<span class="fc" id="L149">            double[] queryParamArray = (double[]) queryParam;</span>
<span class="fc" id="L150">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L152">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L154">            return objectArray;</span>
        }
<span class="fc bfc" id="L156" title="All 2 branches covered.">        else if(queryParam.getClass().getComponentType() == boolean.class) {</span>
<span class="fc" id="L157">            boolean[] queryParamArray = (boolean[]) queryParam;</span>
<span class="fc" id="L158">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L160">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L162">            return objectArray;</span>
        }
        else {
<span class="fc" id="L165">            char[] queryParamArray = (char[]) queryParam;</span>
<span class="fc" id="L166">            Object[] objectArray = new Object[queryParamArray.length];</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamArray.length; i++) {</span>
<span class="fc" id="L168">                objectArray[i] = (Object) queryParamArray[i];</span>
            }
<span class="fc" id="L170">            return objectArray;</span>
        }
    }

    /**
    * Gets the value of the queryParam to be used in the query. 
    * Returns string to replace the respective ${prop} in query parsed from XML. 
    * Accepts primitive(&amp; wrapper), date, string, and array of these types.
    * @param queryParam Parameter(s) to be used in the query.
    * @return The raw SQL query
     * @throws Exception
    */
    private static &lt;P&gt; String getValueForPropertyPlaceholders(P queryParam) {
<span class="fc" id="L183">        String toBeReplacedBy = new String(&quot;&quot;);</span>
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">        if(isWrapperType(queryParam.getClass()) || queryParam.getClass() == Date.class) {</span>
            //primitive type wrappers
<span class="fc" id="L186">            toBeReplacedBy = queryParam.toString().trim();</span>
        }
<span class="fc bfc" id="L188" title="All 2 branches covered.">        else if(queryParam.getClass() == String.class) {</span>
            //string type
<span class="fc" id="L190">            toBeReplacedBy = new String(&quot;\'&quot; + queryParam.toString().trim() + &quot;\'&quot;);</span>
        }
<span class="fc bfc" id="L192" title="All 2 branches covered.">        else if(queryParam.getClass().isArray()) {</span>
            //array
            Object[] queryParamObjects;
            //convert to object array
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if(queryParam.getClass().getComponentType().isPrimitive()) {</span>
<span class="fc" id="L197">                queryParamObjects = getObjectArrayFromPrimitiveArrayObject(queryParam);</span>
            }
            else {
<span class="fc" id="L200">                queryParamObjects = (Object[]) queryParam;</span>
            }
<span class="fc" id="L202">            toBeReplacedBy = toBeReplacedBy + &quot;(&quot;;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            for(int i=0; i&lt;queryParamObjects.length; i++) {</span>
<span class="fc" id="L204">                String eachValue = new String(&quot;&quot;);</span>
<span class="fc" id="L205">                eachValue = queryParamObjects[i].toString();</span>
                //add &quot;&quot; if object is of type string
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if(queryParamObjects.getClass().getComponentType() == String.class) {</span>
<span class="fc" id="L208">                    eachValue = &quot;\'&quot; + eachValue + &quot;\'&quot;;</span>
                }
<span class="fc" id="L210">                toBeReplacedBy = toBeReplacedBy + eachValue;</span>
                //add , in between if not the last object
<span class="fc bfc" id="L212" title="All 2 branches covered.">                if(i &lt; queryParamObjects.length-1) {</span>
<span class="fc" id="L213">                    toBeReplacedBy = toBeReplacedBy + &quot;, &quot;;</span>
                } 
            }
<span class="fc" id="L216">            toBeReplacedBy = toBeReplacedBy + &quot;)&quot;;</span>
<span class="fc" id="L217">        }</span>
        else {
<span class="fc" id="L219">            throw new RuntimeException(&quot;Parameter fields must be primitive(wrapper), string, array/collection type only.&quot;);</span>
        }
<span class="fc" id="L221">        return toBeReplacedBy;</span>
    }

    /**
    * Populates a raw SQL query with the fields of parameter received
    * @param rawQuery raw SQL query
    * @param queryParam Parameter(s) to be used in the query.
    * @return The populated SQL query
     * @throws Exception
    */
    public &lt;P&gt; String populateRawQuery(String rawQuery, P queryParam) {
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if(queryParam == null) {</span>
            //if no parameters for query, return the raw query itself
<span class="fc" id="L234">            return rawQuery;</span>
        }
<span class="fc" id="L236">        String populatedQuery = new String(&quot;&quot;);</span>
<span class="fc" id="L237">        Field[] paramFields = queryParam.getClass().getDeclaredFields();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if(isWrapperType(queryParam.getClass()) //primitive wrappers</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            || queryParam.getClass() == Date.class //date</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            || queryParam.getClass() == String.class //string</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            || queryParam.getClass().isArray()) { //array</span>
<span class="fc" id="L242">            populatedQuery = rawQuery.replace(&quot;${value}&quot;, getValueForPropertyPlaceholders(queryParam));</span>
        }
<span class="fc bfc" id="L244" title="All 2 branches covered.">        else if(queryParam instanceof Collection) {</span>
            //collection type
            //convert to object array and then use getValueForPropertyPlaceholders method
<span class="fc" id="L247">            Collection&lt;?&gt; queryParamCollection = (Collection&lt;?&gt;) queryParam; </span>
<span class="fc" id="L248">            Object[] queryParamObjects = queryParamCollection.toArray();</span>
<span class="fc" id="L249">            populatedQuery = rawQuery.replace(&quot;${value}&quot;, getValueForPropertyPlaceholders(queryParamObjects));</span>
<span class="fc" id="L250">        }</span>
        else {
            //generic class type
<span class="fc bfc" id="L253" title="All 2 branches covered.">            while (rawQuery.indexOf(&quot;${&quot;) != -1) {</span>
<span class="fc" id="L254">                int start = rawQuery.indexOf(&quot;${&quot;);</span>
<span class="fc" id="L255">                int end = rawQuery.indexOf(&quot;}&quot;);</span>
<span class="fc" id="L256">                String propName = rawQuery.substring(start+2, end);</span>
<span class="fc" id="L257">                String propValue = &quot;&quot;;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                for(int i=0; i&lt;paramFields.length; i++) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                    if(propName.equals(paramFields[i].getName())) {</span>
<span class="fc" id="L260">                        Object propObject = new Object();</span>
                        try {
<span class="fc" id="L262">                            propObject = paramFields[i].get(queryParam);</span>
<span class="fc" id="L263">                        } catch (Exception e) {}</span>
<span class="fc" id="L264">                        propValue = getValueForPropertyPlaceholders(propObject);</span>
<span class="fc" id="L265">                        break;</span>
                    }
                }
                //if such property doesn't exist
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if(propValue.equals(&quot;&quot;)) {</span>
<span class="fc" id="L270">                    throw new RuntimeException(&quot;No field &quot; + propName + &quot; for class &quot; + queryParam.getClass().getName() + &quot; found&quot;);</span>
                }
<span class="fc" id="L272">                rawQuery = rawQuery.substring(0, start) + propValue + rawQuery.substring(end+1);</span>
<span class="fc" id="L273">            }</span>
<span class="fc" id="L274">            populatedQuery = rawQuery;</span>
        }
<span class="fc" id="L276">        return populatedQuery;</span>
    }

    private &lt;P&gt; ResultSet getResultSet(String queryId, P queryParam) {
        try {
<span class="fc" id="L281">        String rawQuery = this.getRawQueryFromXML(queryId, queryParam);</span>
<span class="fc" id="L282">        String finalQuery = this.populateRawQuery(rawQuery, queryParam);</span>
<span class="fc" id="L283">        Statement dbStatement = dbConnection.createStatement();</span>
        
<span class="fc" id="L285">        ResultSet resultSet = dbStatement.executeQuery(finalQuery);</span>
<span class="fc" id="L286">        return resultSet;</span>
<span class="nc" id="L287">    } catch(Exception e) {</span>
<span class="nc" id="L288">        throw new RuntimeException(e);</span>
    }
    }

    /**
     * Executes a select query that returns a single or no record.
     * @param queryId Unique ID of the query in the queries.xml file.
     * @param queryParam Parameter(s) to be used in the query.
     * @param resultType Type of the object that will be returned after populating it with the data returned by the SQL.
     * @return The object populated with the SQL results.
     */
    public &lt;R, P&gt; R selectOne(String queryId, P queryParam, Class&lt;R&gt; resultType) {  
        try {
            //Get resultSet and the corresponding meta data
<span class="fc" id="L302">            ResultSet resultSet = this.getResultSet(queryId, queryParam);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if(!resultSet.next()) {</span>
<span class="fc" id="L304">                return null;</span>
            }
<span class="fc" id="L306">            ResultSetMetaData rsMetaData = resultSet.getMetaData();</span>

            //Initialize return object and corresponding fields in it's class
<span class="fc" id="L309">            R sqlResult = resultType.getDeclaredConstructor().newInstance();</span>
<span class="fc" id="L310">            Field[] resultTypeFields = sqlResult.getClass().getDeclaredFields();</span>
<span class="fc" id="L311">            List&lt;String&gt; resultTypeFieldNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            for(int a=0; a&lt;resultTypeFields.length; a++) {</span>
<span class="fc" id="L313">                resultTypeFieldNames.add(resultTypeFields[a].getName());</span>
            }

            //populate POJO for all columns in select query
<span class="fc bfc" id="L317" title="All 2 branches covered.">            for(int i=1; i&lt;=rsMetaData.getColumnCount(); i++) {</span>
<span class="fc" id="L318">                String columnName = rsMetaData.getColumnLabel(i);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                if(resultTypeFieldNames.contains(columnName)) {</span>
                    //setter function for field &quot;name&quot; is -&gt; setName
<span class="fc" id="L321">                    String setterMethodName = &quot;set&quot; + columnName.substring(0, 1).toUpperCase() + columnName.substring(1);</span>
                    
                    //find the field to get its class type
<span class="fc bfc" id="L324" title="All 2 branches covered.">                    for(int j=0; j&lt;resultTypeFields.length; j++) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                        if(resultTypeFields[j].getName().equals(columnName)) {</span>
<span class="fc" id="L326">                            Method setterMethod = sqlResult.getClass().getDeclaredMethod(setterMethodName, resultTypeFields[j].getType());</span>
<span class="fc" id="L327">                            setterMethod.invoke(sqlResult, resultSet.getObject(columnName));</span>
                            //resultTypeFields[j].set(sqlResult, resultSet.getObject(columnName));
                        }
                    }
<span class="fc" id="L331">                }</span>
                else {
<span class="fc" id="L333">                    throw new RuntimeException(&quot;Field &quot; + rsMetaData.getColumnLabel(i) + &quot; doesn't exist for class &quot; + resultType.getClass().getName());</span>
                }
            }

<span class="fc" id="L337">            return sqlResult;</span>
<span class="fc" id="L338">        } catch(Exception e) {</span>
<span class="fc" id="L339">            throw new RuntimeException(e);</span>
        }
    }
 
    /**
     * Same as {@link #selectOne(String, P, Class&lt;R&gt;)} except that this one returns multiple rows.
     * @param queryId
     * @param queryParam
     * @param resultItemType
     * @return The object populated with the SQL results.
     */
    public &lt;R, P&gt; List&lt;R&gt; selectMany(String queryId, P queryParam, Class&lt;R&gt; resultItemType) {
        try {
            //Get resultSet and the corresponding meta data
<span class="fc" id="L353">            ResultSet resultSet = this.getResultSet(queryId, queryParam);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if(!resultSet.next()) {</span>
<span class="fc" id="L355">                return null;</span>
            }
<span class="fc" id="L357">            ResultSetMetaData rsMetaData = resultSet.getMetaData();</span>

            //Initialize return object item and corresponding fields in it's class
<span class="fc" id="L360">            R tempSqlResultItem = resultItemType.getDeclaredConstructor().newInstance();</span>
<span class="fc" id="L361">            Field[] resultTypeFields = tempSqlResultItem.getClass().getDeclaredFields();</span>
<span class="fc" id="L362">            List&lt;String&gt; resultTypeFieldNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            for(int a=0; a&lt;resultTypeFields.length; a++) {</span>
<span class="fc" id="L364">                resultTypeFieldNames.add(resultTypeFields[a].getName());</span>
            }

            //final result list
<span class="fc" id="L368">            List&lt;R&gt; sqlResultList = new ArrayList&lt;&gt;();</span>

            //repeat for all rows in query result
            do {
<span class="fc" id="L372">                R sqlResultItem = resultItemType.getDeclaredConstructor().newInstance();</span>
                //populate POJO for all columns in select query
<span class="fc bfc" id="L374" title="All 2 branches covered.">                for(int i=1; i&lt;=rsMetaData.getColumnCount(); i++) {</span>
<span class="fc" id="L375">                    String columnName = rsMetaData.getColumnLabel(i);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">                    if(resultTypeFieldNames.contains(columnName)) {</span>
                        //setter function for field &quot;name&quot; is -&gt; setName
<span class="fc" id="L378">                        String setterMethodName = &quot;set&quot; + columnName.substring(0, 1).toUpperCase() + columnName.substring(1);</span>
                        
                        //find the field to get its class type
<span class="fc bfc" id="L381" title="All 2 branches covered.">                        for(int j=0; j&lt;resultTypeFields.length; j++) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                            if(resultTypeFields[j].getName().equals(columnName)) {</span>
<span class="fc" id="L383">                                Method setterMethod = sqlResultItem.getClass().getMethod(setterMethodName, resultTypeFields[j].getType());</span>
<span class="fc" id="L384">                                setterMethod.invoke(sqlResultItem, resultSet.getObject(columnName));</span>
                                //resultTypeFields[j].set(sqlResultItem, resultSet.getObject(columnName));
                            }
                        }
<span class="fc" id="L388">                    }</span>
                    else {
<span class="fc" id="L390">                        throw new RuntimeException(&quot;Field &quot; + rsMetaData.getColumnLabel(i) + &quot; doesn't exist for class &quot; + resultItemType.getClass().getName());</span>
                    }
                }

                //add the item in the final result list
<span class="fc" id="L395">                sqlResultList.add(sqlResultItem);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            } while (resultSet.next());</span>

<span class="fc" id="L398">            return sqlResultList;</span>
<span class="fc" id="L399">        } catch(Exception e) {</span>
<span class="fc" id="L400">            throw new RuntimeException(e);</span>
        }
    }
 
    /**
     * Execute an update statement and return the number of rows affected.
     * @param queryId
     * @param queryParam
     * @return number of rows affected
     */
    public &lt;P&gt; int update(String queryId, P queryParam) {
        try {
<span class="fc" id="L412">            String rawQuery = this.getRawQueryFromXML(queryId, queryParam);</span>
<span class="fc" id="L413">            String finalQuery = this.populateRawQuery(rawQuery, queryParam);</span>

<span class="fc" id="L415">            Statement dbStatement = dbConnection.createStatement();</span>
            
<span class="fc" id="L417">            int numRowsAffected = dbStatement.executeUpdate(finalQuery);</span>
<span class="fc" id="L418">            return numRowsAffected;</span>
<span class="fc" id="L419">        } catch(Exception e) {</span>
<span class="fc" id="L420">            throw new RuntimeException(e);</span>
        }
    }
 
    /**
     * Execute an insert statement and return the number of rows affected.
     * @param queryId
     * @param queryParam
     * @return number of rows affected
     * @throws Exception
     */
    public &lt;P&gt; int insert(String queryId, P queryParam) {
        try {
<span class="fc" id="L433">            String rawQuery = this.getRawQueryFromXML(queryId, queryParam);</span>
<span class="fc" id="L434">            String finalQuery = this.populateRawQuery(rawQuery, queryParam);</span>

<span class="fc" id="L436">            Statement dbStatement = dbConnection.createStatement();</span>
            
<span class="fc" id="L438">            int numRowsAffected = dbStatement.executeUpdate(finalQuery);</span>
<span class="fc" id="L439">            return numRowsAffected;</span>
<span class="fc" id="L440">        } catch(Exception e) {</span>
<span class="fc" id="L441">            throw new RuntimeException(e);</span>
        }
    }
 
    /**
     * Execute a delete statement and return the number of rows affected.
     * @param queryId
     * @param queryParam
     * @return number of rows affected
     */
    public &lt;P&gt; int delete(String queryId, P queryParam) {
        try {
<span class="fc" id="L453">            String rawQuery = this.getRawQueryFromXML(queryId, queryParam);</span>
<span class="fc" id="L454">            String finalQuery = this.populateRawQuery(rawQuery, queryParam);</span>

<span class="fc" id="L456">            Statement dbStatement = dbConnection.createStatement();</span>
            
<span class="fc" id="L458">            int numRowsAffected = dbStatement.executeUpdate(finalQuery);</span>
<span class="fc" id="L459">            return numRowsAffected;</span>
<span class="fc" id="L460">        } catch(Exception e) {</span>
<span class="fc" id="L461">            throw new RuntimeException(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>